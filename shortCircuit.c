#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          buggyAttachment, tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int RIGHT_TURN_DEGREES = 150;
const int LEFT_TURN_DEGREES = 150;
const int FIRST_INTERSECTION_COUNT = 2,SECOND_INTERSECTION_COUNT = 1, THIRD_INTERSECTION_COUNT = 1, FOURTH_INTERSECTION_COUNT = 3;
const int TURN_SPEED = 100;
const float INCREMENT_AMOUNT = .16;
int lastTurnDirection = -1;

const int RIGHT_TURN_FLAG = 1;
const int LEFT_TURN_FLAG = 0;

void turnRightAndMoveForward() {

	turnRight(RIGHT_TURN_DEGREES, degrees, TURN_SPEED);
	forward(7, seconds, 50);

}

void incrementForwardUntilIntersection(int numberOfIntersections) {

int bumpCounter = 0;

	while (numberOfIntersections > 0) {
		wait1Msec(50);
		if(getColorReflected(colorSensor) < 80) {
			numberOfIntersections -= 1;
			if(numberOfIntersections > 0)
				forward(INCREMENT_AMOUNT, rotations, 50);
			else
				break;
		}
		forward(INCREMENT_AMOUNT, rotations, 50);
		if(bumpCounter % 50 == 0 && lastTurnDirection == RIGHT_TURN_FLAG) {
			turnLeft(.01, rotations, 50);
		}
		if(bumpCounter % 50 == 0 && lastTurnDirection == LEFT_TURN_FLAG) {
			turnRight(.01, rotations, 50);
		}
		bumpCounter += 1;
	}
}

void enterIntersectionAndTurn(int direction) {
	forward(1.25, rotations, 50);
	if(direction == LEFT_TURN_FLAG)
		turnLeft(LEFT_TURN_DEGREES, degrees, TURN_SPEED);
	if(direction == RIGHT_TURN_FLAG) {
		turnRight(RIGHT_TURN_DEGREES, degrees, TURN_SPEED);
	}
}

task main()
{


	wait1Msec(50);
	turnRightAndMoveForward();
	lastTurnDirection = RIGHT_TURN_FLAG;
	incrementForwardUntilIntersection(FIRST_INTERSECTION_COUNT);
	enterIntersectionAndTurn(LEFT_TURN_FLAG);
	lastTurnDirection = LEFT_TURN_FLAG;
	incrementForwardUntilIntersection(SECOND_INTERSECTION_COUNT);
	enterIntersectionAndTurn(LEFT_TURN_FLAG);
	incrementForwardUntilIntersection(THIRD_INTERSECTION_COUNT);
	enterIntersectionAndTurn(RIGHT_TURN_FLAG);
	lastTurnDirection = RIGHT_TURN_FLAG;
	incrementForwardUntilIntersection(FOURTH_INTERSECTION_COUNT);
	enterIntersectionAndTurn(RIGHT_TURN_FLAG);

}
